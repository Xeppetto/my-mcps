#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import axios from 'axios';
// .env 파일 대신 환경변수에서 직접 읽음

// MCP 서버 인스턴스 생성
const server = new Server(
  {
    name: 'jira-mcp-server',
    version: '0.1.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// 도구 목록 정의
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'get_user_issues',
        description: '특정 사용자가 생성한 이슈 조회',
        inputSchema: {
          type: 'object',
          properties: {
            username: {
              type: 'string',
              description: 'Jira 사용자명 또는 이메일',
            },
            days: {
              type: 'number',
              description: '조회할 일수 (기본값: 7일)',
              default: 7,
            },
          },
          required: ['username'],
        },
      },
      {
        name: 'get_user_comments',
        description: '특정 사용자가 댓글을 단 이슈들 조회',
        inputSchema: {
          type: 'object',
          properties: {
            username: {
              type: 'string',
              description: 'Jira 사용자명 또는 이메일',
            },
            days: {
              type: 'number',
              description: '조회할 일수 (기본값: 7일)',
              default: 7,
            },
          },
          required: ['username'],
        },
      },
      {
        name: 'get_issue_comments',
        description: '특정 이슈의 댓글 상세 조회',
        inputSchema: {
          type: 'object',
          properties: {
            issueKey: {
              type: 'string',
              description: '이슈 키 (예: EZQA-1258)',
            },
            username: {
              type: 'string',
              description: '특정 사용자의 댓글만 필터링 (선택사항)',
            },
          },
          required: ['issueKey'],
        },
      },
    ],
  };
});

// 도구 실행 핸들러
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'get_user_issues':
        return await getUserIssues(args.username, args.days || 7);
      
      case 'get_user_comments':
        return await getUserComments(args.username, args.days || 7);
      
      case 'get_issue_comments':
        return await getIssueComments(args.issueKey, args.username);
      
      
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error.message}`,
        },
      ],
    };
  }
});

// Jira API 설정
const JIRA_BASE_URL = process.env.JIRA_URL;
const JIRA_EMAIL = process.env.JIRA_EMAIL;
const JIRA_API_TOKEN = process.env.JIRA_API_TOKEN;

// Jira API 클라이언트 설정
const jiraClient = axios.create({
  baseURL: JIRA_BASE_URL,
  auth: {
    username: JIRA_EMAIL,
    password: JIRA_API_TOKEN,
  },
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
  },
});

// 사용자가 생성한 이슈 조회 함수
async function getUserIssues(username, days) {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  const dateStr = startDate.toISOString().split('T')[0];

  try {
    const response = await jiraClient.get('/rest/api/3/search', {
      params: {
        jql: `reporter = "${username}" AND created >= "${dateStr}"`,
        fields: 'key,summary,status,created,priority,issuetype',
        maxResults: 100,
      },
    });

    const issues = response.data.issues.map(issue => ({
      key: issue.key,
      summary: issue.fields.summary,
      status: issue.fields.status.name,
      created: issue.fields.created,
      priority: issue.fields.priority?.name || 'None',
      issueType: issue.fields.issuetype.name,
    }));

    return {
      content: [
        {
          type: 'text',
          text: `${username}님이 최근 ${days}일 동안 생성한 이슈 (총 ${issues.length}개):\n\n` +
                issues.map(issue => 
                  `• [${issue.key}] ${issue.summary}\n` +
                  `  상태: ${issue.status} | 우선순위: ${issue.priority} | 유형: ${issue.issueType}\n` +
                  `  생성일: ${new Date(issue.created).toLocaleString('ko-KR')}\n`
                ).join('\n'),
        },
      ],
    };
  } catch (error) {
    throw new Error(`Jira API 호출 실패: ${error.response?.data?.errorMessages || error.message}`);
  }
}

// 사용자가 댓글을 단 이슈 조회 함수 (개선된 버전)
async function getUserComments(username, days) {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  const dateStr = startDate.toISOString().split('T')[0];

  try {
    // 방법 1: 최근 업데이트된 이슈들을 가져와서 댓글 필터링
    console.error(`댓글 조회 시도: ${username}, ${days}일`);
    
    let commentDetails = [];
    let searchApproach = 'updated-issues';
    
    try {
      // 먼저 commentedBy 필드를 사용해보기
      const response = await jiraClient.get('/rest/api/3/search', {
        params: {
          jql: `commentedBy = "${username}" AND updated >= "${dateStr}"`,
          fields: 'key,summary,status,updated',
          maxResults: 50,
        },
      });
      
      console.error(`commentedBy 필드 사용 성공: ${response.data.issues.length}개 이슈`);
      commentDetails = await processIssuesForComments(response.data.issues, username, startDate);
      
    } catch (commentedByError) {
      console.error(`commentedBy 필드 사용 실패: ${commentedByError.message}`);
      
      // 대안 방법: 최근 업데이트된 모든 이슈를 가져와서 수동으로 댓글 확인
      searchApproach = 'manual-filter';
      const response = await jiraClient.get('/rest/api/3/search', {
        params: {
          jql: `updated >= "${dateStr}" ORDER BY updated DESC`,
          fields: 'key,summary,status,updated',
          maxResults: 100,
        },
      });
      
      console.error(`대안 방법 사용: ${response.data.issues.length}개 이슈 검토`);
      commentDetails = await processIssuesForComments(response.data.issues, username, startDate);
    }

    const totalComments = commentDetails.reduce((sum, issue) => sum + issue.comments.length, 0);

    return {
      content: [
        {
          type: 'text',
          text: `${username}님의 최근 ${days}일 댓글 활동 (${searchApproach === 'updated-issues' ? 'commentedBy 필드 사용' : '수동 필터링'}):\n\n` +
                `📊 **요약**: ${commentDetails.length}개 이슈, ${totalComments}개 댓글\n\n` +
                (commentDetails.length > 0 ? 
                  commentDetails.map(issue => 
                    `🎫 **[${issue.issueKey}]** ${issue.issueSummary}\n` +
                    `   📋 상태: ${issue.issueStatus}\n` +
                    issue.comments.map(comment => 
                      `   💬 ${new Date(comment.created).toLocaleString('ko-KR')}\n` +
                      `      "${comment.body.substring(0, 200)}${comment.body.length > 200 ? '...' : ''}"\n`
                    ).join('') + '\n'
                  ).join('') :
                  '이 기간 동안 댓글 활동이 없습니다.\n'
                ),
        },
      ],
    };
  } catch (error) {
    // 권한 부족 시 대안 메시지 제공
    if (error.response?.status === 400 || error.response?.status === 403) {
      return {
        content: [
          {
            type: 'text',
            text: `❌ 댓글 조회 권한 부족\n\n` +
                  `**문제**: ${error.response?.data?.errorMessages?.[0] || error.message}\n\n` +
                  `**해결 방법**:\n` +
                  `1. 🔑 Jira 관리자에게 댓글 조회 권한 요청\n` +
                  `2. 👥 프로젝트 멤버십 확인\n` +
                  `3. 🛠️ API 토큰 권한 범위 확인\n` +
                  `4. 📋 프로젝트별 권한 설정 점검\n\n` +
                  `**대안**: 개별 이슈 상세 조회를 통해 댓글 확인 가능합니다.`,
          },
        ],
      };
    }
    throw new Error(`Jira API 호출 실패: ${error.response?.data?.errorMessages || error.message}`);
  }
}

// 이슈들에서 특정 사용자의 댓글 추출하는 헬퍼 함수
async function processIssuesForComments(issues, username, startDate) {
  const commentDetails = [];
  
  for (const issue of issues.slice(0, 20)) { // 성능을 위해 최대 20개 이슈만 처리
    try {
      const commentsResponse = await jiraClient.get(`/rest/api/3/issue/${issue.key}/comment`, {
        params: {
          orderBy: '-created', // 최신 댓글부터
          maxResults: 50,
        },
      });
      
      const userComments = commentsResponse.data.comments.filter(comment => {
        const commentDate = new Date(comment.created);
        const commentAuthor = comment.author?.emailAddress || comment.author?.displayName || '';
        
        return commentDate >= startDate && 
               (commentAuthor === username || 
                commentAuthor.toLowerCase().includes(username.toLowerCase()) ||
                comment.author?.displayName === username);
      });

      if (userComments.length > 0) {
        commentDetails.push({
          issueKey: issue.key,
          issueSummary: issue.fields.summary,
          issueStatus: issue.fields.status.name,
          comments: userComments.map(comment => ({
            body: extractCommentText(comment.body),
            created: comment.created,
            author: comment.author?.displayName || 'Unknown',
          })),
        });
      }
    } catch (commentError) {
      console.error(`이슈 ${issue.key} 댓글 조회 실패:`, commentError.message);
      continue; // 개별 이슈 실패는 무시하고 계속 진행
    }
  }
  
  return commentDetails;
}

// 댓글 본문 텍스트 추출 함수
function extractCommentText(commentBody) {
  if (typeof commentBody === 'string') {
    return commentBody;
  }
  
  if (commentBody?.content) {
    // ADF (Atlassian Document Format) 처리
    return extractTextFromADF(commentBody.content);
  }
  
  return JSON.stringify(commentBody);
}

// ADF에서 텍스트 추출
function extractTextFromADF(content) {
  let text = '';
  
  if (Array.isArray(content)) {
    content.forEach(node => {
      if (node.type === 'paragraph' && node.content) {
        node.content.forEach(textNode => {
          if (textNode.type === 'text' && textNode.text) {
            text += textNode.text + ' ';
          }
        });
      } else if (node.type === 'text' && node.text) {
        text += node.text + ' ';
      }
    });
  }
  
  return text.trim() || '(텍스트 추출 실패)';
}

// 특정 이슈의 댓글 상세 조회 함수
async function getIssueComments(issueKey, username) {
  try {
    const commentsResponse = await jiraClient.get(`/rest/api/3/issue/${issueKey}/comment`, {
      params: {
        orderBy: '-created',
        maxResults: 100,
      },
    });

    let comments = commentsResponse.data.comments;
    
    // 특정 사용자 필터링
    if (username) {
      comments = comments.filter(comment => {
        const author = comment.author?.emailAddress || comment.author?.displayName || '';
        return author === username || 
               author.toLowerCase().includes(username.toLowerCase()) ||
               comment.author?.displayName === username;
      });
    }

    const commentDetails = comments.map(comment => ({
      id: comment.id,
      author: comment.author?.displayName || 'Unknown',
      authorEmail: comment.author?.emailAddress || '',
      created: comment.created,
      updated: comment.updated,
      body: extractCommentText(comment.body),
    }));

    return {
      content: [
        {
          type: 'text',
          text: `🎫 **이슈 ${issueKey} 댓글 조회** ${username ? `(${username} 사용자만)` : ''}\n\n` +
                `📊 **총 ${commentDetails.length}개 댓글**\n\n` +
                (commentDetails.length > 0 ?
                  commentDetails.map((comment, index) =>
                    `**${index + 1}. ${comment.author}** (${comment.authorEmail})\n` +
                    `📅 작성: ${new Date(comment.created).toLocaleString('ko-KR')}\n` +
                    `${comment.updated !== comment.created ? `📝 수정: ${new Date(comment.updated).toLocaleString('ko-KR')}\n` : ''}` +
                    `💬 내용: ${comment.body}\n\n`
                  ).join('') :
                  '댓글이 없습니다.\n'
                ),
        },
      ],
    };
  } catch (error) {
    throw new Error(`이슈 댓글 조회 실패: ${error.response?.data?.errorMessages || error.message}`);
  }
}

// 서버 시작
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('Jira MCP Server running on stdio');
}

main().catch(console.error);